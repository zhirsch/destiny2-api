// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// DestinyDefinitionsItemsDestinyItemPlugDefinition If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.
// This gives information about when it can be inserted, what the plug's category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
// swagger:model Destiny.Definitions.Items.DestinyItemPlugDefinition

type DestinyDefinitionsItemsDestinyItemPlugDefinition struct {

	// It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
	EnabledMaterialRequirementHash uint32 `json:"enabledMaterialRequirementHash,omitempty"`

	// enabled rules
	EnabledRules DestinyDefinitionsItemsDestinyItemPlugDefinitionEnabledRules `json:"enabledRules"`

	// If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
	InsertionMaterialRequirementHash uint32 `json:"insertionMaterialRequirementHash,omitempty"`

	// insertion rules
	InsertionRules DestinyDefinitionsItemsDestinyItemPlugDefinitionInsertionRules `json:"insertionRules"`

	// If you successfully socket the item, this will determine whether or not you get "refunded" on the plug.
	OnActionRecreateSelf bool `json:"onActionRecreateSelf,omitempty"`

	// The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
	PlugCategoryHash uint32 `json:"plugCategoryHash,omitempty"`

	// The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
	PlugCategoryIdentifier string `json:"plugCategoryIdentifier,omitempty"`

	// In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
	PreviewItemOverrideHash uint32 `json:"previewItemOverrideHash,omitempty"`
}

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition enabledMaterialRequirementHash false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition enabledRules false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition insertionMaterialRequirementHash false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition insertionRules false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition onActionRecreateSelf false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition plugCategoryHash false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition plugCategoryIdentifier false */

/* polymorph Destiny.Definitions.Items.DestinyItemPlugDefinition previewItemOverrideHash false */

// Validate validates this destiny definitions items destiny item plug definition
func (m *DestinyDefinitionsItemsDestinyItemPlugDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *DestinyDefinitionsItemsDestinyItemPlugDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DestinyDefinitionsItemsDestinyItemPlugDefinition) UnmarshalBinary(b []byte) error {
	var res DestinyDefinitionsItemsDestinyItemPlugDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
