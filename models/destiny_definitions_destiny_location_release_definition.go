// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// DestinyDefinitionsDestinyLocationReleaseDefinition A specific "spot" referred to by a location. Only one of these can be active at a time for a given Location.
// swagger:model Destiny.Definitions.DestinyLocationReleaseDefinition

type DestinyDefinitionsDestinyLocationReleaseDefinition struct {

	// The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's bubbles and bubbleSettings properties.
	ActivityBubbleName uint32 `json:"activityBubbleName,omitempty"`

	// The Activity Graph being pointed to by this location.
	ActivityGraphHash uint32 `json:"activityGraphHash,omitempty"`

	// The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes are only unique within an Activity Graph: so use the combination to find the node being spoken of)
	ActivityGraphNodeHash uint32 `json:"activityGraphNodeHash,omitempty"`

	// The Activity being pointed to by this location.
	ActivityHash uint32 `json:"activityHash,omitempty"`

	// If we had map information, this would tell us something cool about the path this location wants you to take. I wish we had map information.
	ActivityPathBundle uint32 `json:"activityPathBundle,omitempty"`

	// If we had map information, this would tell us about path information related to destination on the map. Sad. Maybe you can do something cool with it. Go to town man.
	ActivityPathDestination uint32 `json:"activityPathDestination,omitempty"`

	// The Destination being pointed to by this location.
	DestinationHash uint32 `json:"destinationHash,omitempty"`

	// Sadly, these don't appear to be populated anymore (ever?)
	DisplayProperties *DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition `json:"displayProperties,omitempty"`

	// The type of Nav Point that this represents. See the enumeration for more info.
	NavPointType DestinyDestinyActivityNavPointType `json:"navPointType,omitempty"`

	// If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info.
	SpawnPoint uint32 `json:"spawnPoint,omitempty"`

	// Looks like it should be the position on the map, but sadly it does not look populated... yet?
	WorldPosition []int32 `json:"worldPosition"`
}

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityBubbleName false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityGraphHash false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityGraphNodeHash false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityHash false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityPathBundle false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition activityPathDestination false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition destinationHash false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition displayProperties false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition navPointType false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition spawnPoint false */

/* polymorph Destiny.Definitions.DestinyLocationReleaseDefinition worldPosition false */

// Validate validates this destiny definitions destiny location release definition
func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDisplayProperties(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNavPointType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateWorldPosition(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) validateDisplayProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayProperties) { // not required
		return nil
	}

	if m.DisplayProperties != nil {

		if err := m.DisplayProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("displayProperties")
			}
			return err
		}
	}

	return nil
}

func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) validateNavPointType(formats strfmt.Registry) error {

	if swag.IsZero(m.NavPointType) { // not required
		return nil
	}

	if err := m.NavPointType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("navPointType")
		}
		return err
	}

	return nil
}

func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) validateWorldPosition(formats strfmt.Registry) error {

	if swag.IsZero(m.WorldPosition) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DestinyDefinitionsDestinyLocationReleaseDefinition) UnmarshalBinary(b []byte) error {
	var res DestinyDefinitionsDestinyLocationReleaseDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
