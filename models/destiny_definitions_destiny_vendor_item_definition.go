// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// DestinyDefinitionsDestinyVendorItemDefinition This represents an item being sold by the vendor.
// swagger:model Destiny.Definitions.DestinyVendorItemDefinition

type DestinyDefinitionsDestinyVendorItemDefinition struct {

	// The action to be performed when purchasing the item, if it's not just "buy".
	Action *DestinyDefinitionsDestinyVendorSaleItemActionBlockDefinition `json:"action,omitempty"`

	// The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.
	CategoryIndex int32 `json:"categoryIndex,omitempty"`

	// creation levels
	CreationLevels DestinyDefinitionsDestinyVendorItemDefinitionCreationLevels `json:"creationLevels"`

	// currencies
	Currencies DestinyDefinitionsDestinyVendorItemDefinitionCurrencies `json:"currencies"`

	// The string identifier for the category selling this item.
	DisplayCategory string `json:"displayCategory,omitempty"`

	// This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)
	DisplayCategoryIndex int32 `json:"displayCategoryIndex,omitempty"`

	// An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.
	FailureIndexes []int32 `json:"failureIndexes"`

	// The inventory bucket into which this item will be placed upon purchase.
	InventoryBucketHash uint32 `json:"inventoryBucketHash,omitempty"`

	// The hash identifier of the item being sold (DestinyInventoryItemDefinition).
	// Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity.
	ItemHash uint32 `json:"itemHash,omitempty"`

	// The maximum character level at which this item is available for sale.
	MaximumLevel int32 `json:"maximumLevel,omitempty"`

	// The minimum character level at which this item is available for sale.
	MinimumLevel int32 `json:"minimumLevel,omitempty"`

	// Same as above, but for the original category indexes.
	OriginalCategoryIndex int32 `json:"originalCategoryIndex,omitempty"`

	// Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.
	// See DestinyGatingScope's documentation for more information.
	PurchasableScope DestinyDestinyGatingScope `json:"purchasableScope,omitempty"`

	// The amount you will recieve of the item described in itemHash if you make the purchase.
	Quantity int32 `json:"quantity,omitempty"`

	// If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.
	RefundPolicy DestinyDestinyVendorItemRefundPolicy `json:"refundPolicy,omitempty"`

	// The amount of time before refundability of the newly purchased item will expire.
	RefundTimeLimit int32 `json:"refundTimeLimit,omitempty"`

	// The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.
	VendorItemIndex int32 `json:"vendorItemIndex,omitempty"`

	// The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.
	// This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).
	VisibilityScope DestinyDestinyGatingScope `json:"visibilityScope,omitempty"`
}

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition action false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition categoryIndex false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition creationLevels false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition currencies false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition displayCategory false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition displayCategoryIndex false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition failureIndexes false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition inventoryBucketHash false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition itemHash false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition maximumLevel false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition minimumLevel false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition originalCategoryIndex false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition purchasableScope false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition quantity false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition refundPolicy false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition refundTimeLimit false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition vendorItemIndex false */

/* polymorph Destiny.Definitions.DestinyVendorItemDefinition visibilityScope false */

// Validate validates this destiny definitions destiny vendor item definition
func (m *DestinyDefinitionsDestinyVendorItemDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFailureIndexes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePurchasableScope(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRefundPolicy(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVisibilityScope(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DestinyDefinitionsDestinyVendorItemDefinition) validateAction(formats strfmt.Registry) error {

	if swag.IsZero(m.Action) { // not required
		return nil
	}

	if m.Action != nil {

		if err := m.Action.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("action")
			}
			return err
		}
	}

	return nil
}

func (m *DestinyDefinitionsDestinyVendorItemDefinition) validateFailureIndexes(formats strfmt.Registry) error {

	if swag.IsZero(m.FailureIndexes) { // not required
		return nil
	}

	return nil
}

func (m *DestinyDefinitionsDestinyVendorItemDefinition) validatePurchasableScope(formats strfmt.Registry) error {

	if swag.IsZero(m.PurchasableScope) { // not required
		return nil
	}

	if err := m.PurchasableScope.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("purchasableScope")
		}
		return err
	}

	return nil
}

func (m *DestinyDefinitionsDestinyVendorItemDefinition) validateRefundPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RefundPolicy) { // not required
		return nil
	}

	if err := m.RefundPolicy.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("refundPolicy")
		}
		return err
	}

	return nil
}

func (m *DestinyDefinitionsDestinyVendorItemDefinition) validateVisibilityScope(formats strfmt.Registry) error {

	if swag.IsZero(m.VisibilityScope) { // not required
		return nil
	}

	if err := m.VisibilityScope.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("visibilityScope")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DestinyDefinitionsDestinyVendorItemDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DestinyDefinitionsDestinyVendorItemDefinition) UnmarshalBinary(b []byte) error {
	var res DestinyDefinitionsDestinyVendorItemDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
